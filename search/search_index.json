{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"tutorial/","text":"The command you just ran \u00b6 Congratulations! You have started the container for this tutorial! Let's first explain the command that you just ran. In case you forgot, here's the command: docker run --name=makeen-labs -d -p 8080:80 maghbari/makeen-labs:1.1 You'll notice a few flags being used. Here's some more info on them: -d - run the container in detached mode (in the background) -p 8080:80 - map port 8080 of the host to port 80 in the container maghbari/makeen-labs:1.1 - the image to us The Docker Dashboard \u00b6 Before going any further, we want to highlight the Docker Dashboard, which gives you a quick view of the containers running on your machine. It provides you access to container logs, lets you get a shell inside the container, and allows you to easily manage container lifecycle (stop, remove, etc.). What is a container? \u00b6 Now that you've successfully run a container, let's ask ourselves what is a container? Simply put, a container is another process on your machine that has been isolated from all other processes on the host machine. Features that have been in Linux for a long time. Docker has worked to make these capabilities approachable and easy to use. What is a container image? \u00b6 When running a container, it uses an isolated filesystem. This custom filesystem is provided by a container image . Since the image contains the container's filesystem, it must include everything needed to run the application - all dependencies, configuration, scripts, binaries, etc. The image also contains other configuration for the container, such as environment variables, a default command to run, and other metadata. We'll dive deeper into images later on, covering topics such as layering, best practices, and more.","title":"Getting Started"},{"location":"tutorial/#the-command-you-just-ran","text":"Congratulations! You have started the container for this tutorial! Let's first explain the command that you just ran. In case you forgot, here's the command: docker run --name=makeen-labs -d -p 8080:80 maghbari/makeen-labs:1.1 You'll notice a few flags being used. Here's some more info on them: -d - run the container in detached mode (in the background) -p 8080:80 - map port 8080 of the host to port 80 in the container maghbari/makeen-labs:1.1 - the image to us","title":"The command you just ran"},{"location":"tutorial/#the-docker-dashboard","text":"Before going any further, we want to highlight the Docker Dashboard, which gives you a quick view of the containers running on your machine. It provides you access to container logs, lets you get a shell inside the container, and allows you to easily manage container lifecycle (stop, remove, etc.).","title":"The Docker Dashboard"},{"location":"tutorial/#what-is-a-container","text":"Now that you've successfully run a container, let's ask ourselves what is a container? Simply put, a container is another process on your machine that has been isolated from all other processes on the host machine. Features that have been in Linux for a long time. Docker has worked to make these capabilities approachable and easy to use.","title":"What is a container?"},{"location":"tutorial/#what-is-a-container-image","text":"When running a container, it uses an isolated filesystem. This custom filesystem is provided by a container image . Since the image contains the container's filesystem, it must include everything needed to run the application - all dependencies, configuration, scripts, binaries, etc. The image also contains other configuration for the container, such as environment variables, a default command to run, and other metadata. We'll dive deeper into images later on, covering topics such as layering, best practices, and more.","title":"What is a container image?"},{"location":"tutorial/image-building-best-practices/","text":"","title":"Image Building Best Practices"},{"location":"tutorial/multi-container-apps/","text":"Up to this point, we have been working with single container apps. But, we now want to add MSSQL Server DB to the application stack. The following question often arises - \"Where will MSSQL Server run? Install it in the same container or run it separately?\" In general, each container should do one thing and do it well. A few reasons: There's a good chance you'd have to scale APIs and front-ends differently than databases. Separate containers let you version and update versions in isolation. While you may use a container for the database locally, you may want to use a managed service for the database in production. You don't want to ship your database engine with your app then. Running multiple processes will require a process manager (the container only starts one process), which adds complexity to container startup/shutdown. Container Networking \u00b6 Remember that containers, by default, run in isolation and don't know anything about other processes or containers on the same machine. So, how do we allow one container to talk to another? The answer is networking . Now, you don't have to be a network engineer. Simply remember this rule... If two containers are on the same network, they can talk to each other. If they aren't, they can't. Starting MSSQL Server \u00b6 There are two ways to put a container on a network: 1) Assign it at start or 2) connect an existing container. For now, we will create the network first and attach the MSSQL Server container at startup. Create the network. docker network create bank-network Pull the official MS SQLServer docker image from docker hub https://hub.docker.com/_/microsoft-mssql-server docker pull mcr.microsoft.com/mssql/server:2022-latest Start a MSSQL Server container and attach it to the network. We're also going to define a few environment variables that the database will use to initialize the database (see the \"Environment Variables\" section in the Microsoft Learn ). Remeber: This tutorial uses a simple password CBY@123456 as an example for this tutorial, your password will always be different ```bash docker run -d --network=bank-network --name mssql-server -p 1433:1433 -e \"ACCEPT_EULA=Y\" -e \"MSSQL_SA_PASSWORD=CBY@123456\" -e \"MSSQL_PID=Evaluation\" -v mssql_volume:/var/opt/mssql -d mcr.microsoft.com/mssql/server:2022-latest ```` !!! info \"Pro-tip\" You will notice we're using a volume named `mssql_volume` here and mounting it at `/var/opt/mssql`, which is where MSSQL Server stores its data. However, we never ran a `docker volume create` command. Docker recognizes we want to use a named volume and creates one automatically for us. To confirm we have the database up and running, connect to the database and verify it connects. docker exec -it mssql-server /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P CBY@123456 -Q \"sp_databases\" You should see output that looks like this: +--------------------+--------------------+ | DATABASE_NAME | DATABASE_SIZE | +--------------------+--------------------+ | master | 6848 NULL | | model | 16384 NULL | | msdb | 16960 NULL | | tmpdb | 73728 NULL | +--------------------+--------------------+ Creating Simple Data \u00b6 Now that we know MSSQL Server is up and running, but before using it in our app, we need to create simple data in our database Clone the BankSimpleApp Repository git clone https://github.com/fintech-ye/BankSimpleApp.git Now change the working directory into the repo directory by executing: cd BankSimpleApp Execute the following docker cp command to copy .sql files into mssql-server docker container docker cp ./db_init/ mssql-server:/tmp/ The above command will copy the directory db_init into the MSSQL Server container. The directory db_init contains two files db_create.sql and db_insert.sql . The files content look like the following: IF NOT EXISTS ( SELECT name FROM sys . databases WHERE name = 'cby' ) BEGIN CREATE DATABASE cby ; END IF object_id ( 'cby.dbo.#accounts' ) is not null BEGIN CREATE TABLE [ cby ].[ dbo ].[ accounts ] ( [ BIC ] VARCHAR ( 50 ) NOT NULL , [ account_name ] VARCHAR ( 50 ) NOT NULL , [ balance ] INT CONSTRAINT [ DEFAULT_accounts_balance ] DEFAULT (( 0 )) NOT NULL , [ bank_code ] CHAR ( 10 ) NULL , [ currency ] CHAR ( 10 ) CONSTRAINT [ DEFAULT_accounts_currency ] DEFAULT (( 886 )) NOT NULL , CONSTRAINT [ PK_accounts ] PRIMARY KEY CLUSTERED ([ BIC ] ASC ) ); END DELETE FROM cby . dbo . accounts ; INSERT INTO cby . dbo . accounts ( BIC , account_name , balance , bank_code , currency ) VALUES ( 'CBYEYESA' , 'Central Bank of Yemen' , 1000000000 , 'CBYE' , '886' ), ( 'KRMBYESA' , 'Kuraimi Islamic Bank' , 50000000 , 'KRMB' , '886' ), ( 'YKBAYESA' , 'Yemen Kuwait Bank' , 25500000 , 'YKBA' , '886' ), ( 'CACAYESA' , 'CAC Bank' , 84000000 , 'CACB' , '886' ); Execute the following docker exec command, to create a new database called cby and a table called accounts , in addition to inserting 4 records into the accounts table. docker exec -it mssql-server /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P CBY@123456 -i /tmp/db_init/db_create.sql -i /tmp/db_init/db_insert.sql The command docker exec is used to execute a command inside a specific container. So in the previous command, we have run a utility tool called sqlcmd (which is inside the mssql-server container) to execute the .sql files we have previously copied to the container. Ensure that our test data has been generated by executing: docker exec -it mssql-server /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P CBY@123456 -Q \"select * from cby.dbo.accounts\" You should see output that looks like this: BIC account_name balance bank_code currency ------------------------------- ----------------------------------------- ----------- ---------- ---------- CACAYESA CAC Bank 84000000 CACB 886 CBYEYESA Central Bank of Yemen 1000000000 CBYE 886 KRMBYESA Kuraimi Islamic Bank 50000000 KRMB 886 YKBAYESA Yemen Kuwait Bank 25500000 YKBA 886 Now our MSSQL Server container mssql-server is ready, let's use it! But, the question is... how? If we run our app container on the same network, how our app will find the database container? Simply, our app only needs to connect to the db using a host named mssql-server which as also the name of the MSSQL Server container and it'll talk to the database! See, It doesn't get much simpler than that! Running our BankSimpleApp with MSSQL Server \u00b6 The BankSimpleApp app supports the setting of a few environment variables to specify MSSQL connection settings. They are: DB_SERVER - the hostname for the running MSSQL server DB_UID - the username to use for the connection DB_PASSWD - the password to use for the connection DB_NAME - the database to use once connected Warning While using env vars to set connection settings is generally ok for development, it is HIGHLY DISCOURAGED when running applications in production. A more secure mechanism is to use the secret support provided by a container orchestration framework, such as Kubernetes . With all of that explained, let's start our dev-ready container! Pull the docker image from docker hub https://hub.docker.com/r/maghbari/bank-simple-app docker pull maghbari/bank-simple-app We'll specify each of the environment variables above, as well as connect the container to our app network. docker run -d --network = bank-network --name = bank-app -p 8080 :80 -e DB_SERVER = \"mssql-server,1433\" -e DB_NAME = \"cby\" -e DB_UID = \"sa\" -e DB_PASSWD = \"CBY@123456\" maghbari/bank-simple-app After a few seconds, open your web browser to http://localhost:8080 . You should see our container app bank-app has queried and viewed bank accounts data from mssql-server container which is running on the same network bank-network with our app. If you take a quick look at the Docker Dashboard, you'll see that we have two app containers running. But, there's no real indication that they are grouped together in a single app. We'll see how to make that better shortly! Recap \u00b6 At this point, we have an application that now stores its data in an external database running in a separate container. We learned a little bit about container networking and saw how service discovery can be performed simply using containers names. But, there's a good chance you are starting to feel a little overwhelmed with everything you need to do to start up this application. We have to create a network, start containers, specify all of the environment variables, expose ports, and more! That's a lot to remember and it's certainly making things harder to pass along to someone else. In the next section, we'll talk about Docker Compose. With Docker Compose, we can share our application stacks in a much easier way and let others spin them up with a single (and simple) command!","title":"Multi-Container Apps"},{"location":"tutorial/multi-container-apps/#container-networking","text":"Remember that containers, by default, run in isolation and don't know anything about other processes or containers on the same machine. So, how do we allow one container to talk to another? The answer is networking . Now, you don't have to be a network engineer. Simply remember this rule... If two containers are on the same network, they can talk to each other. If they aren't, they can't.","title":"Container Networking"},{"location":"tutorial/multi-container-apps/#starting-mssql-server","text":"There are two ways to put a container on a network: 1) Assign it at start or 2) connect an existing container. For now, we will create the network first and attach the MSSQL Server container at startup. Create the network. docker network create bank-network Pull the official MS SQLServer docker image from docker hub https://hub.docker.com/_/microsoft-mssql-server docker pull mcr.microsoft.com/mssql/server:2022-latest Start a MSSQL Server container and attach it to the network. We're also going to define a few environment variables that the database will use to initialize the database (see the \"Environment Variables\" section in the Microsoft Learn ). Remeber: This tutorial uses a simple password CBY@123456 as an example for this tutorial, your password will always be different ```bash docker run -d --network=bank-network --name mssql-server -p 1433:1433 -e \"ACCEPT_EULA=Y\" -e \"MSSQL_SA_PASSWORD=CBY@123456\" -e \"MSSQL_PID=Evaluation\" -v mssql_volume:/var/opt/mssql -d mcr.microsoft.com/mssql/server:2022-latest ```` !!! info \"Pro-tip\" You will notice we're using a volume named `mssql_volume` here and mounting it at `/var/opt/mssql`, which is where MSSQL Server stores its data. However, we never ran a `docker volume create` command. Docker recognizes we want to use a named volume and creates one automatically for us. To confirm we have the database up and running, connect to the database and verify it connects. docker exec -it mssql-server /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P CBY@123456 -Q \"sp_databases\" You should see output that looks like this: +--------------------+--------------------+ | DATABASE_NAME | DATABASE_SIZE | +--------------------+--------------------+ | master | 6848 NULL | | model | 16384 NULL | | msdb | 16960 NULL | | tmpdb | 73728 NULL | +--------------------+--------------------+","title":"Starting MSSQL Server"},{"location":"tutorial/multi-container-apps/#creating-simple-data","text":"Now that we know MSSQL Server is up and running, but before using it in our app, we need to create simple data in our database Clone the BankSimpleApp Repository git clone https://github.com/fintech-ye/BankSimpleApp.git Now change the working directory into the repo directory by executing: cd BankSimpleApp Execute the following docker cp command to copy .sql files into mssql-server docker container docker cp ./db_init/ mssql-server:/tmp/ The above command will copy the directory db_init into the MSSQL Server container. The directory db_init contains two files db_create.sql and db_insert.sql . The files content look like the following: IF NOT EXISTS ( SELECT name FROM sys . databases WHERE name = 'cby' ) BEGIN CREATE DATABASE cby ; END IF object_id ( 'cby.dbo.#accounts' ) is not null BEGIN CREATE TABLE [ cby ].[ dbo ].[ accounts ] ( [ BIC ] VARCHAR ( 50 ) NOT NULL , [ account_name ] VARCHAR ( 50 ) NOT NULL , [ balance ] INT CONSTRAINT [ DEFAULT_accounts_balance ] DEFAULT (( 0 )) NOT NULL , [ bank_code ] CHAR ( 10 ) NULL , [ currency ] CHAR ( 10 ) CONSTRAINT [ DEFAULT_accounts_currency ] DEFAULT (( 886 )) NOT NULL , CONSTRAINT [ PK_accounts ] PRIMARY KEY CLUSTERED ([ BIC ] ASC ) ); END DELETE FROM cby . dbo . accounts ; INSERT INTO cby . dbo . accounts ( BIC , account_name , balance , bank_code , currency ) VALUES ( 'CBYEYESA' , 'Central Bank of Yemen' , 1000000000 , 'CBYE' , '886' ), ( 'KRMBYESA' , 'Kuraimi Islamic Bank' , 50000000 , 'KRMB' , '886' ), ( 'YKBAYESA' , 'Yemen Kuwait Bank' , 25500000 , 'YKBA' , '886' ), ( 'CACAYESA' , 'CAC Bank' , 84000000 , 'CACB' , '886' ); Execute the following docker exec command, to create a new database called cby and a table called accounts , in addition to inserting 4 records into the accounts table. docker exec -it mssql-server /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P CBY@123456 -i /tmp/db_init/db_create.sql -i /tmp/db_init/db_insert.sql The command docker exec is used to execute a command inside a specific container. So in the previous command, we have run a utility tool called sqlcmd (which is inside the mssql-server container) to execute the .sql files we have previously copied to the container. Ensure that our test data has been generated by executing: docker exec -it mssql-server /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P CBY@123456 -Q \"select * from cby.dbo.accounts\" You should see output that looks like this: BIC account_name balance bank_code currency ------------------------------- ----------------------------------------- ----------- ---------- ---------- CACAYESA CAC Bank 84000000 CACB 886 CBYEYESA Central Bank of Yemen 1000000000 CBYE 886 KRMBYESA Kuraimi Islamic Bank 50000000 KRMB 886 YKBAYESA Yemen Kuwait Bank 25500000 YKBA 886 Now our MSSQL Server container mssql-server is ready, let's use it! But, the question is... how? If we run our app container on the same network, how our app will find the database container? Simply, our app only needs to connect to the db using a host named mssql-server which as also the name of the MSSQL Server container and it'll talk to the database! See, It doesn't get much simpler than that!","title":"Creating Simple Data"},{"location":"tutorial/multi-container-apps/#running-our-banksimpleapp-with-mssql-server","text":"The BankSimpleApp app supports the setting of a few environment variables to specify MSSQL connection settings. They are: DB_SERVER - the hostname for the running MSSQL server DB_UID - the username to use for the connection DB_PASSWD - the password to use for the connection DB_NAME - the database to use once connected Warning While using env vars to set connection settings is generally ok for development, it is HIGHLY DISCOURAGED when running applications in production. A more secure mechanism is to use the secret support provided by a container orchestration framework, such as Kubernetes . With all of that explained, let's start our dev-ready container! Pull the docker image from docker hub https://hub.docker.com/r/maghbari/bank-simple-app docker pull maghbari/bank-simple-app We'll specify each of the environment variables above, as well as connect the container to our app network. docker run -d --network = bank-network --name = bank-app -p 8080 :80 -e DB_SERVER = \"mssql-server,1433\" -e DB_NAME = \"cby\" -e DB_UID = \"sa\" -e DB_PASSWD = \"CBY@123456\" maghbari/bank-simple-app After a few seconds, open your web browser to http://localhost:8080 . You should see our container app bank-app has queried and viewed bank accounts data from mssql-server container which is running on the same network bank-network with our app. If you take a quick look at the Docker Dashboard, you'll see that we have two app containers running. But, there's no real indication that they are grouped together in a single app. We'll see how to make that better shortly!","title":"Running our BankSimpleApp with MSSQL Server"},{"location":"tutorial/multi-container-apps/#recap","text":"At this point, we have an application that now stores its data in an external database running in a separate container. We learned a little bit about container networking and saw how service discovery can be performed simply using containers names. But, there's a good chance you are starting to feel a little overwhelmed with everything you need to do to start up this application. We have to create a network, start containers, specify all of the environment variables, expose ports, and more! That's a lot to remember and it's certainly making things harder to pass along to someone else. In the next section, we'll talk about Docker Compose. With Docker Compose, we can share our application stacks in a much easier way and let others spin them up with a single (and simple) command!","title":"Recap"},{"location":"tutorial/our-application/","text":"Running our first App \u00b6 For the rest of this tutorial, we will be working with a simple dotnet core asp app written in C#. If you're not familiar with C#, don't worry! No real C# experience is needed! At this point, your development team is quite small and you're simply building an app to prove out your MVP (minimum viable product). You want to show how it works and what it's capable of doing without needing to think about how it will work for a large team, multiple developers, etc. Getting the App - dotnet-example-app \u00b6 Before we can run the application, we need to get the application source code onto our machine. For real projects, you will typically clone the repo. But, for this tutorial, we have created a ZIP file containing the application. Clone the application source code from github https://github.com/fintech-ye/dotnet-example-app git clone https://github.com/fintech-ye/dotnet-example-app Note: If you can't get access to the repository, please contact me at: alaghbri.mohammed@gmail.com Building the App's Container Image \u00b6 In order to build the application, we need to use a Dockerfile . A Dockerfile is simply a text-based script of instructions that is used to create a container image. If you've created Dockerfiles before, you might see a few flaws in the Dockerfile below. But, don't worry! We'll go over them. Create a file named Dockerfile in the same folder as the file Program.cs with the following contents. FROM mcr.microsoft.com/dotnet/sdk:7.0 AS build-env WORKDIR /dotnet-example-app # Copy everything COPY . ./ # Restore as distinct layers RUN dotnet restore # Build and publish a release RUN dotnet publish -c Release -o out # Build runtime image FROM mcr.microsoft.com/dotnet/aspnet:7.0 WORKDIR /dotnet-example COPY --from = build-env /dotnet-example-app/out . EXPOSE 80 ENTRYPOINT [ \"dotnet\" , \"dotnet-example-app.dll\" ] Please check that the file Dockerfile has no file extension like .txt . Some editors may append this file extension automatically and this would result in an error in the next step. If you haven't already done so, open a terminal and go to the app directory with the Dockerfile . Now build the container image using the docker build command. docker build -t dotnet-example-app . This command used the Dockerfile to build a new container image. You might have noticed that a lot of \"layers\" were downloaded. This is because we instructed the builder that we wanted to start from the images mcr.microsoft.com/dotnet/sdk:7.0 and mcr.microsoft.com/dotnet/aspnet:7.0 . But, since we didn't have that on our machine, that image needed to be downloaded. After the images were downloaded, we copied in our application and used dotnet command to install our application's dependencies. The CMD directive specifies the default command to run when starting a container from this image. Finally, the -t flag tags our image. Think of this simply as a human-readable name for the final image. Since we named the image dotnet-example-app , we can refer to that image when we run a container. The . at the end of the docker build command tells that Docker should look for the Dockerfile in the current directory. Starting an App Container \u00b6 Now that we have an image, let's run the application! To do so, we will use the docker run command. Start your container using the docker run command and specify the name of the image we just created: docker run --name = dotnet-example-app -d -p 8088 :80 dotnet-example-app Remember the -d and -p flags? We're running the new container in \"detached\" mode (in the background) and creating a mapping between the host's port 8088 to the container's port 80. Without the port mapping, we wouldn't be able to access the application. After a few seconds, open your web browser to http://localhost:8088 . You should see our app! Go ahead and add an item or two and see that it works as you expect. You can mark items as complete and remove items. Your frontend is successfully storing items in the backend! Pretty quick and easy, huh? At this point, you should have a running todo list manager with a few items, all built by you! Now, let's make a few changes and learn about managing our containers. If you take a quick look at the Docker Dashboard, you should see your two containers running now (this tutorial and your freshly launched app container)! Recap \u00b6 In this short section, we learned the very basics about building a container image and created a Dockerfile to do so. Once we built an image, we started the container and saw the running app! Next, we're going to make a modification to our app and learn how to update our running application with a new image. Along the way, we'll learn a few other useful commands.","title":"First Application"},{"location":"tutorial/our-application/#running-our-first-app","text":"For the rest of this tutorial, we will be working with a simple dotnet core asp app written in C#. If you're not familiar with C#, don't worry! No real C# experience is needed! At this point, your development team is quite small and you're simply building an app to prove out your MVP (minimum viable product). You want to show how it works and what it's capable of doing without needing to think about how it will work for a large team, multiple developers, etc.","title":"Running our first App"},{"location":"tutorial/our-application/#getting-the-app-dotnet-example-app","text":"Before we can run the application, we need to get the application source code onto our machine. For real projects, you will typically clone the repo. But, for this tutorial, we have created a ZIP file containing the application. Clone the application source code from github https://github.com/fintech-ye/dotnet-example-app git clone https://github.com/fintech-ye/dotnet-example-app Note: If you can't get access to the repository, please contact me at: alaghbri.mohammed@gmail.com","title":"Getting the App - dotnet-example-app"},{"location":"tutorial/our-application/#building-the-apps-container-image","text":"In order to build the application, we need to use a Dockerfile . A Dockerfile is simply a text-based script of instructions that is used to create a container image. If you've created Dockerfiles before, you might see a few flaws in the Dockerfile below. But, don't worry! We'll go over them. Create a file named Dockerfile in the same folder as the file Program.cs with the following contents. FROM mcr.microsoft.com/dotnet/sdk:7.0 AS build-env WORKDIR /dotnet-example-app # Copy everything COPY . ./ # Restore as distinct layers RUN dotnet restore # Build and publish a release RUN dotnet publish -c Release -o out # Build runtime image FROM mcr.microsoft.com/dotnet/aspnet:7.0 WORKDIR /dotnet-example COPY --from = build-env /dotnet-example-app/out . EXPOSE 80 ENTRYPOINT [ \"dotnet\" , \"dotnet-example-app.dll\" ] Please check that the file Dockerfile has no file extension like .txt . Some editors may append this file extension automatically and this would result in an error in the next step. If you haven't already done so, open a terminal and go to the app directory with the Dockerfile . Now build the container image using the docker build command. docker build -t dotnet-example-app . This command used the Dockerfile to build a new container image. You might have noticed that a lot of \"layers\" were downloaded. This is because we instructed the builder that we wanted to start from the images mcr.microsoft.com/dotnet/sdk:7.0 and mcr.microsoft.com/dotnet/aspnet:7.0 . But, since we didn't have that on our machine, that image needed to be downloaded. After the images were downloaded, we copied in our application and used dotnet command to install our application's dependencies. The CMD directive specifies the default command to run when starting a container from this image. Finally, the -t flag tags our image. Think of this simply as a human-readable name for the final image. Since we named the image dotnet-example-app , we can refer to that image when we run a container. The . at the end of the docker build command tells that Docker should look for the Dockerfile in the current directory.","title":"Building the App's Container Image"},{"location":"tutorial/our-application/#starting-an-app-container","text":"Now that we have an image, let's run the application! To do so, we will use the docker run command. Start your container using the docker run command and specify the name of the image we just created: docker run --name = dotnet-example-app -d -p 8088 :80 dotnet-example-app Remember the -d and -p flags? We're running the new container in \"detached\" mode (in the background) and creating a mapping between the host's port 8088 to the container's port 80. Without the port mapping, we wouldn't be able to access the application. After a few seconds, open your web browser to http://localhost:8088 . You should see our app! Go ahead and add an item or two and see that it works as you expect. You can mark items as complete and remove items. Your frontend is successfully storing items in the backend! Pretty quick and easy, huh? At this point, you should have a running todo list manager with a few items, all built by you! Now, let's make a few changes and learn about managing our containers. If you take a quick look at the Docker Dashboard, you should see your two containers running now (this tutorial and your freshly launched app container)!","title":"Starting an App Container"},{"location":"tutorial/our-application/#recap","text":"In this short section, we learned the very basics about building a container image and created a Dockerfile to do so. Once we built an image, we started the container and saw the running app! Next, we're going to make a modification to our app and learn how to update our running application with a new image. Along the way, we'll learn a few other useful commands.","title":"Recap"},{"location":"tutorial/persisting-our-data/","text":"In case you didn't notice, our todo list is being wiped clean every single time we launch the container. Why is this? Let's dive into how the container is working. The Container's Filesystem \u00b6 When a container runs, it uses the various layers from an image for its filesystem. Each container also gets its own \"scratch space\" to create/update/remove files. Any changes won't be seen in another container, even if they are using the same image. Seeing this in Practice \u00b6 To see this in action, let's run the univerity application, an example dotnet core app the reads data from a sqlite data. The app is a web site for a fictional Docker University that includes functionalities such as student admission, course creation, and instructor assignments. Pull the docker image from docker hub https://hub.docker.com/r/maghbari/university-app docker pull maghbari/university-app 1. Start your container using the docker run command and specify the name of the image we just pulled: docker run --name = university-app -d -p 8090 :80 maghbari/university-app After a few seconds, open your web browser to http://localhost:8090 . You should see our app! Using the app UI, Go ahead to Students menu and add a student or two and see that it works as you expect. Refresh the page to ensure the frontend is successfully storing items in the backend. Now, let's remove the container docker rm -f university-app execute docker ps to ensure the container is removed Now, Start the container again using the same command you have previously used: docker run --name = university-app -d -p 8090 :80 maghbari/university-app Go again to Students menu qnd look! The Student you have added are not there! That's because the data was written to the scratch space of the container. Container Volumes \u00b6 With the previous experiment, we saw that each container starts from the image definition each time it starts. While containers can create, update, and delete files, those changes are lost when the container is removed and all changes are isolated to that container. With volumes , we can change all of this. Volumes provide the ability to connect specific filesystem paths of the container back to the host machine. If a directory in the container is mounted, changes in that directory are also seen on the host machine. If we mount that same directory across container restarts, we'd see the same data. There are two main types of volumes. We will eventually use both, but we will start with named volumes . Persisting our Todo Data \u00b6 By default, the university app stores its data in a SQLite Database at /db/CU.db . If you're not familiar with SQLite, no worries! It's simply a relational database in which all of the data is stored in a single file. With the database being a single file, if we can persist that file on the host and make it available to the next container, it should be able to pick up where the last one left off. By creating a volume and attaching (often called \"mounting\") it to the directory the data is stored in, we can persist the data. As our container writes to the CU.db file, it will be persisted to the host in the volume. As mentioned, we are going to use a named volume . Think of a named volume as simply a bucket of data. Docker maintains the physical location on the disk and you only need to remember the name of the volume. Every time you use the volume, Docker will make sure the correct data is provided. Create a volume by using the docker volume create command. docker volume create db_volume Stop the univeristy app container once again in the Dashboard (or with docker rm -f <container-id> ), as it is still running without using the persistent volume. Start the univeristy app container, but add the -v flag to specify a volume mount. We will use the named volume and mount it to /db , which will capture all files created at the path. docker run -d --name university-app -p 8090 :80 -v db_volume:/db/ university-app Once the container starts up, open the app and add a few items through the students menu. Remove the container for the university app. Use the Dashboard or docker ps to get the ID and then docker rm -f <container-id> to remove it. Start a new container using the same command from above. Open the app. You should see all students data still in your list! Go ahead and remove the container when you're done checking out your list. Now You've now learned how to persist data! Pro-tip While named volumes and bind mounts (which we'll talk about in a minute) are the two main types of volumes supported by a default Docker engine installation, there are many volume driver plugins available to support NFS, SFTP, NetApp, and more! This will be especially important once you start running containers on multiple hosts in a clustered environment with like Kubernetes. Diving into our Volume \u00b6 A lot of people frequently ask \"Where is Docker actually storing my data when I use a named volume?\" If you want to know, you can use the docker volume inspect command. docker volume inspect todo-db [ { \"CreatedAt\" : \"2023-10-15T22:14:39Z\" , \"Driver\" : \"local\" , \"Labels\" : null, \"Mountpoint\" : \"/var/lib/docker/volumes/db_volume/_data\" , \"Name\" : \"db_volume\" , \"Options\" : null, \"Scope\" : \"local\" } ] The Mountpoint is the actual location on the disk where the data is stored. Note that on most machines, you will need to have root access to access this directory from the host. But, that's where it is! In the previous chapter, we talked about and used a named volume to persist the data in our database. Named volumes are great if we simply want to store data, as we don't have to worry about where the data is stored. Using Bind Mounts \u00b6 In the previous example, we used a named volume to persist the data in our database. Named volumes are great if we simply want to store data, as we don't have to worry about where the data is stored. With bind mounts , we control the exact mountpoint on the host. We can use this to persist data, but is often used to provide additional data into containers. Let's again work with the university application, but now we will use a bind mount to mount a host path in which the CU.db will be stored. Stop the univeristy app container once again in the Dashboard (or with docker rm -f <container-id> ). Start the univeristy app container, but now the -v flag will specify a binding mount on the host instead of using a named volume. docker run -d --name university-app -p 8090 :80 -v c:/Users/MO/db/:/db/ university-app Note that the binding mount path c:/Users/MO/db/ should be replaced by a path in your host machine. Open the folder where the binding mount path located, and there you will find the database file CU.db Once the container starts up, open the app and add a few items through the students menu. Now try removing and running the container again using the last docker run command we have used You will find that all students data still in your list! At this point, we have a functioning application that can survive restarts or damages!","title":"Persisting our DB"},{"location":"tutorial/persisting-our-data/#the-containers-filesystem","text":"When a container runs, it uses the various layers from an image for its filesystem. Each container also gets its own \"scratch space\" to create/update/remove files. Any changes won't be seen in another container, even if they are using the same image.","title":"The Container's Filesystem"},{"location":"tutorial/persisting-our-data/#seeing-this-in-practice","text":"To see this in action, let's run the univerity application, an example dotnet core app the reads data from a sqlite data. The app is a web site for a fictional Docker University that includes functionalities such as student admission, course creation, and instructor assignments. Pull the docker image from docker hub https://hub.docker.com/r/maghbari/university-app docker pull maghbari/university-app 1. Start your container using the docker run command and specify the name of the image we just pulled: docker run --name = university-app -d -p 8090 :80 maghbari/university-app After a few seconds, open your web browser to http://localhost:8090 . You should see our app! Using the app UI, Go ahead to Students menu and add a student or two and see that it works as you expect. Refresh the page to ensure the frontend is successfully storing items in the backend. Now, let's remove the container docker rm -f university-app execute docker ps to ensure the container is removed Now, Start the container again using the same command you have previously used: docker run --name = university-app -d -p 8090 :80 maghbari/university-app Go again to Students menu qnd look! The Student you have added are not there! That's because the data was written to the scratch space of the container.","title":"Seeing this in Practice"},{"location":"tutorial/persisting-our-data/#container-volumes","text":"With the previous experiment, we saw that each container starts from the image definition each time it starts. While containers can create, update, and delete files, those changes are lost when the container is removed and all changes are isolated to that container. With volumes , we can change all of this. Volumes provide the ability to connect specific filesystem paths of the container back to the host machine. If a directory in the container is mounted, changes in that directory are also seen on the host machine. If we mount that same directory across container restarts, we'd see the same data. There are two main types of volumes. We will eventually use both, but we will start with named volumes .","title":"Container Volumes"},{"location":"tutorial/persisting-our-data/#persisting-our-todo-data","text":"By default, the university app stores its data in a SQLite Database at /db/CU.db . If you're not familiar with SQLite, no worries! It's simply a relational database in which all of the data is stored in a single file. With the database being a single file, if we can persist that file on the host and make it available to the next container, it should be able to pick up where the last one left off. By creating a volume and attaching (often called \"mounting\") it to the directory the data is stored in, we can persist the data. As our container writes to the CU.db file, it will be persisted to the host in the volume. As mentioned, we are going to use a named volume . Think of a named volume as simply a bucket of data. Docker maintains the physical location on the disk and you only need to remember the name of the volume. Every time you use the volume, Docker will make sure the correct data is provided. Create a volume by using the docker volume create command. docker volume create db_volume Stop the univeristy app container once again in the Dashboard (or with docker rm -f <container-id> ), as it is still running without using the persistent volume. Start the univeristy app container, but add the -v flag to specify a volume mount. We will use the named volume and mount it to /db , which will capture all files created at the path. docker run -d --name university-app -p 8090 :80 -v db_volume:/db/ university-app Once the container starts up, open the app and add a few items through the students menu. Remove the container for the university app. Use the Dashboard or docker ps to get the ID and then docker rm -f <container-id> to remove it. Start a new container using the same command from above. Open the app. You should see all students data still in your list! Go ahead and remove the container when you're done checking out your list. Now You've now learned how to persist data! Pro-tip While named volumes and bind mounts (which we'll talk about in a minute) are the two main types of volumes supported by a default Docker engine installation, there are many volume driver plugins available to support NFS, SFTP, NetApp, and more! This will be especially important once you start running containers on multiple hosts in a clustered environment with like Kubernetes.","title":"Persisting our Todo Data"},{"location":"tutorial/persisting-our-data/#diving-into-our-volume","text":"A lot of people frequently ask \"Where is Docker actually storing my data when I use a named volume?\" If you want to know, you can use the docker volume inspect command. docker volume inspect todo-db [ { \"CreatedAt\" : \"2023-10-15T22:14:39Z\" , \"Driver\" : \"local\" , \"Labels\" : null, \"Mountpoint\" : \"/var/lib/docker/volumes/db_volume/_data\" , \"Name\" : \"db_volume\" , \"Options\" : null, \"Scope\" : \"local\" } ] The Mountpoint is the actual location on the disk where the data is stored. Note that on most machines, you will need to have root access to access this directory from the host. But, that's where it is! In the previous chapter, we talked about and used a named volume to persist the data in our database. Named volumes are great if we simply want to store data, as we don't have to worry about where the data is stored.","title":"Diving into our Volume"},{"location":"tutorial/persisting-our-data/#using-bind-mounts","text":"In the previous example, we used a named volume to persist the data in our database. Named volumes are great if we simply want to store data, as we don't have to worry about where the data is stored. With bind mounts , we control the exact mountpoint on the host. We can use this to persist data, but is often used to provide additional data into containers. Let's again work with the university application, but now we will use a bind mount to mount a host path in which the CU.db will be stored. Stop the univeristy app container once again in the Dashboard (or with docker rm -f <container-id> ). Start the univeristy app container, but now the -v flag will specify a binding mount on the host instead of using a named volume. docker run -d --name university-app -p 8090 :80 -v c:/Users/MO/db/:/db/ university-app Note that the binding mount path c:/Users/MO/db/ should be replaced by a path in your host machine. Open the folder where the binding mount path located, and there you will find the database file CU.db Once the container starts up, open the app and add a few items through the students menu. Now try removing and running the container again using the last docker run command we have used You will find that all students data still in your list! At this point, we have a functioning application that can survive restarts or damages!","title":"Using Bind Mounts"},{"location":"tutorial/sharing-our-app/","text":"Now that we've built an image, let's share it! To share Docker images, you have to use a Docker registry. The default registry is Docker Hub and is where all of the images we've used have come from. Create a Repo \u00b6 To push an image, we first need to create a repo on Docker Hub. Go to Docker Hub and log in if you need to. Click the Create Repository button. For the repo name, use dotnet-example-app . Make sure the Visibility is Public . Click the Create button! If you look on the right-side of the page, you'll see a section named Docker commands . This gives an example command that you will need to run to push to this repo. Pushing our Image \u00b6 In the command line, try running the push command you see on Docker Hub. Note that your command will be using your namespace, not \"docker\". $ docker push maghbari/dotnet-example-app The push refers to repository [docker.io/maghbari/dotnet-example-app] An image does not exist locally with the tag: maghbari/dotnet-example-app Why did it fail? The push command was looking for an image named maghbari/dotnet-example-app, but didn't find one. If you run docker image ls , you won't see one either. To fix this, we need to \"tag\" our existing image we've built to give it another name. Login to Docker Hub by either clicking on the \"Sign In\" button in Docker Desktop or using the command docker login -u YOUR-USER-NAME . Use the docker tag command to give the getting-started image a new name. Be sure to swap out YOUR-USER-NAME with your Docker ID. docker tag dotnet-example-app YOUR-USER-NAME/dotnet-example-app Now try your push command again. If you're copying the value from Docker Hub, you can drop the tagname portion, as we didn't add a tag to the image name. If you don't specify a tag, Docker will use a tag called latest . docker push YOUR-USER-NAME/dotnet-example-app The common practice when tagging images is to add the version number of the image before pushing it as the following: docker tag dotnet-example-app YOUR-USER-NAME/dotnet-example-app:1.0 docker push YOUR-USER-NAME/dotnet-example-app:1.0 Running our Image on a New Instance \u00b6 Now that our image has been built and pushed into a registry, let's try running our app on a brand new instance that has never seen this container image! To do this, we will use Play with Docker. Open your browser to Play with Docker . Log in with your Docker Hub account. Once you're logged in, click on the \"+ ADD NEW INSTANCE\" link in the left side bar. (If you don't see it, make your browser a little wider.) After a few seconds, a terminal window will be opened in your browser. In the terminal, start your freshly pushed app. docker run -d -p 8088 :80 YOUR-USER-NAME/dotnet-example-app:1.0 You should see the image get pulled down and eventually start up! Click on the 8088 badge when it comes up and you should see the app with your modifications! If the 8088 badge doesn't show up, you can click on the \"Open Port\" button and type in 8088. Recap \u00b6 In this section, we learned how to share our images by pushing them to a registry. We then went to a brand new instance and were able to run the freshly pushed image. This is quite common in CI pipelines, where the pipeline will create the image and push it to a registry and then the production environment can use the latest version of the image.","title":"Sharing our App"},{"location":"tutorial/sharing-our-app/#create-a-repo","text":"To push an image, we first need to create a repo on Docker Hub. Go to Docker Hub and log in if you need to. Click the Create Repository button. For the repo name, use dotnet-example-app . Make sure the Visibility is Public . Click the Create button! If you look on the right-side of the page, you'll see a section named Docker commands . This gives an example command that you will need to run to push to this repo.","title":"Create a Repo"},{"location":"tutorial/sharing-our-app/#pushing-our-image","text":"In the command line, try running the push command you see on Docker Hub. Note that your command will be using your namespace, not \"docker\". $ docker push maghbari/dotnet-example-app The push refers to repository [docker.io/maghbari/dotnet-example-app] An image does not exist locally with the tag: maghbari/dotnet-example-app Why did it fail? The push command was looking for an image named maghbari/dotnet-example-app, but didn't find one. If you run docker image ls , you won't see one either. To fix this, we need to \"tag\" our existing image we've built to give it another name. Login to Docker Hub by either clicking on the \"Sign In\" button in Docker Desktop or using the command docker login -u YOUR-USER-NAME . Use the docker tag command to give the getting-started image a new name. Be sure to swap out YOUR-USER-NAME with your Docker ID. docker tag dotnet-example-app YOUR-USER-NAME/dotnet-example-app Now try your push command again. If you're copying the value from Docker Hub, you can drop the tagname portion, as we didn't add a tag to the image name. If you don't specify a tag, Docker will use a tag called latest . docker push YOUR-USER-NAME/dotnet-example-app The common practice when tagging images is to add the version number of the image before pushing it as the following: docker tag dotnet-example-app YOUR-USER-NAME/dotnet-example-app:1.0 docker push YOUR-USER-NAME/dotnet-example-app:1.0","title":"Pushing our Image"},{"location":"tutorial/sharing-our-app/#running-our-image-on-a-new-instance","text":"Now that our image has been built and pushed into a registry, let's try running our app on a brand new instance that has never seen this container image! To do this, we will use Play with Docker. Open your browser to Play with Docker . Log in with your Docker Hub account. Once you're logged in, click on the \"+ ADD NEW INSTANCE\" link in the left side bar. (If you don't see it, make your browser a little wider.) After a few seconds, a terminal window will be opened in your browser. In the terminal, start your freshly pushed app. docker run -d -p 8088 :80 YOUR-USER-NAME/dotnet-example-app:1.0 You should see the image get pulled down and eventually start up! Click on the 8088 badge when it comes up and you should see the app with your modifications! If the 8088 badge doesn't show up, you can click on the \"Open Port\" button and type in 8088.","title":"Running our Image on a New Instance"},{"location":"tutorial/sharing-our-app/#recap","text":"In this section, we learned how to share our images by pushing them to a registry. We then went to a brand new instance and were able to run the freshly pushed image. This is quite common in CI pipelines, where the pipeline will create the image and push it to a registry and then the production environment can use the latest version of the image.","title":"Recap"},{"location":"tutorial/updating-our-app/","text":"Now we've been asked by the product team to change the welcome message in our app dotnet-example-app into Welcome to our App Updating our Source Code \u00b6 In the Pages/Index.cshtml file, update line 8 to use the new empty text. - <h1 class=\"display-4\">Welcome</h1> + <h1 class=\"display-4\">Welcome to our App</h1> Let's build our updated version of the image, using the same command we used before. docker build -t dotnet-example-app . Let's start a new container using the updated code. docker run --name = dotnet-example-app -d -p 8088 :80 dotnet-example-app Uh oh! You probably saw an error like this (the IDs will be different): docker: Error response from daemon: driver failed programming external connectivity on endpoint dotnet-example-app-updated ( 7ec2aa11290d7c766dba45c3ab46aaa143fd05ceb4c34b57bd24150fafec8d93 ) : Bind for 0 .0.0.0:8088 failed: port is already allocated. So, what happened? We aren't able to start the new container because our old container is still running. The reason this is a problem is because that container is using the host's port 8088 and only one process on the machine (containers included) can listen to a specific port. To fix this, we need to remove the old container. Replacing our Old Container \u00b6 To remove a container, it first needs to be stopped. Once it has stopped, it can be removed. We have two ways that we can remove the old container. Feel free to choose the path that you're most comfortable with. Removing a container using the CLI \u00b6 Get the ID of the container by using the docker ps command. docker ps Use the docker stop command to stop the container. # Swap out <the-container-id> with the ID from docker ps docker stop <the-container-id> Once the container has stopped, you can remove it by using the docker rm command. docker rm <the-container-id> Pro tip You can stop and remove a container in a single command by adding the \"force\" flag to the docker rm command. For example: docker rm -f <the-container-id> Removing a container using the Docker Dashboard \u00b6 If you open the Docker dashboard, you can remove a container with two clicks! It's certainly much easier than having to look up the container ID and remove it. With the dashboard opened, hover over the app container and you'll see a collection of action buttons appear on the right. Click on the trash can icon to delete the container. Confirm the removal and you're done! Starting our updated app container \u00b6 Now, start your updated app. docker run --name = dotnet-example-app -d -p 8088 :80 dotnet-example-app Refresh your browser on http://localhost:8088 and you should see your updated welcome text! Next, we'll see how to share these images with others.","title":"Updating First App"},{"location":"tutorial/updating-our-app/#updating-our-source-code","text":"In the Pages/Index.cshtml file, update line 8 to use the new empty text. - <h1 class=\"display-4\">Welcome</h1> + <h1 class=\"display-4\">Welcome to our App</h1> Let's build our updated version of the image, using the same command we used before. docker build -t dotnet-example-app . Let's start a new container using the updated code. docker run --name = dotnet-example-app -d -p 8088 :80 dotnet-example-app Uh oh! You probably saw an error like this (the IDs will be different): docker: Error response from daemon: driver failed programming external connectivity on endpoint dotnet-example-app-updated ( 7ec2aa11290d7c766dba45c3ab46aaa143fd05ceb4c34b57bd24150fafec8d93 ) : Bind for 0 .0.0.0:8088 failed: port is already allocated. So, what happened? We aren't able to start the new container because our old container is still running. The reason this is a problem is because that container is using the host's port 8088 and only one process on the machine (containers included) can listen to a specific port. To fix this, we need to remove the old container.","title":"Updating our Source Code"},{"location":"tutorial/updating-our-app/#replacing-our-old-container","text":"To remove a container, it first needs to be stopped. Once it has stopped, it can be removed. We have two ways that we can remove the old container. Feel free to choose the path that you're most comfortable with.","title":"Replacing our Old Container"},{"location":"tutorial/updating-our-app/#removing-a-container-using-the-cli","text":"Get the ID of the container by using the docker ps command. docker ps Use the docker stop command to stop the container. # Swap out <the-container-id> with the ID from docker ps docker stop <the-container-id> Once the container has stopped, you can remove it by using the docker rm command. docker rm <the-container-id> Pro tip You can stop and remove a container in a single command by adding the \"force\" flag to the docker rm command. For example: docker rm -f <the-container-id>","title":"Removing a container using the CLI"},{"location":"tutorial/updating-our-app/#removing-a-container-using-the-docker-dashboard","text":"If you open the Docker dashboard, you can remove a container with two clicks! It's certainly much easier than having to look up the container ID and remove it. With the dashboard opened, hover over the app container and you'll see a collection of action buttons appear on the right. Click on the trash can icon to delete the container. Confirm the removal and you're done!","title":"Removing a container using the Docker Dashboard"},{"location":"tutorial/updating-our-app/#starting-our-updated-app-container","text":"Now, start your updated app. docker run --name = dotnet-example-app -d -p 8088 :80 dotnet-example-app Refresh your browser on http://localhost:8088 and you should see your updated welcome text! Next, we'll see how to share these images with others.","title":"Starting our updated app container"},{"location":"tutorial/using-docker-compose/","text":"","title":"Using Docker Compose"},{"location":"tutorial/what-next/","text":"","title":"What Next?"}]}